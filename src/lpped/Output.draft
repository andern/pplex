/*
 * Copyright (C) 2012 Andreas Halle
 *
 * This file is part of lpped.
 *
 * lpped is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * lpped is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public license
 * along with lpped. If not, see <http://www.gnu.org/licenses/>.
 */
package lpped;



public class Output {
    /**
     * Return a nicely formatted {@code String} that represents the
     * matrix-vector product of this {@code Matrix} and the given
     * vector given as an {@code Array}.
     *
     * @param  x
     *         A vector as an {@code array} of {@code Strings}.
     * @param  precision
     *         Limit each double precision number to this many decimals.
     *         Give a negative value to automatically set precision.
     * @return
     *         A nicely formatted {@code String}.
     */
    protected String toString(String[] x, int precision) {
        if (x.length != n) {
            String e = String.format("Illegal matrix operation: Cannot"
                                         + " multiply a %d x %d matrix"
                                         + " with a vector whose dimension"
                                         + " is %d.", m, n, x.length);
            throw new IllegalArgumentException(e);
        }
        
        String[][] elements = vectorProduct(x, precision);
        int[] lCol = colSizes(elements);
        boolean posfcol = positiveCol(0);
        
        return niceFormat(elements, lCol, posfcol);
    }
    
    
    
    private String niceFormat(String[][] elements, int[] lCol, boolean fCol) {
        StringBuilder sb = new StringBuilder();
        
        for (int i = 0; i < m; i++) {
            if (i != 0) {
                sb.append("\n");
            }
            
            for (int j = 0; j < n; j++) {
                if (j != 0) {
                    sb.append(" ");
                }
                char sign = signify(data[i][j], j);
                String var = spaceVar(sign, elements[i][j], j, lCol[j], fCol);
                sb.append(var);
            }
        }
        return sb.toString();
    }
    
    
    
    private String spaceVar(char sgn, String ele, int col, int lcol,
                                                            boolean posfcol) {
        String f = String.format("%%c %%%ds", lcol);
        if (col == 0 && posfcol) {
            f = String.format("%%%ds", lcol);
            return String.format(f, ele);
        }
        return String.format(f, sgn, ele);
    }
    
    
    
    /*
     * Return the sign to put in front of
     * the coefficient-variable product.
     */
    private char signify(double coeff, int column) {
        char sign = ' ';
        if (coeff > 0 && column != 0) {
            sign = '+';
        } else if (coeff < 0) {
            sign = '-';
        }
        return sign;
    }
    
    
    
    /*
     * Return false if column j has any
     * negative numbers. Return true otherwise.
     */
    private boolean positiveCol(int j) {
        for (int i = 0; i < m; i++) {
            if (data[i][j] < 0) {
                return false;
            }
        }
        return true;
    }
    
    
    
    /*
     * Return an array containing the length
     * of the longest string in each column.
     */
    private int[] colSizes(String[][] elements) {
        int[] colSizes = new int[elements[0].length];
        for (int j = 0; j < elements[0].length; j++) {
            int max = 1;
            for (int i = 0; i < elements.length; i++) {
                int len = elements[i][j].length();
                
                if (len > max) {
                    max = len;
                }
            }
            colSizes[j] = max;
        }
        return colSizes;
    }
    
    
    
    /*
     * Calculate the product of each element in the matrix.
     */
    private String[][] vectorProduct(String[] x, int precision) {
        String[][] elements = new String[m][n];
        
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                double coeff = Math.abs(data[j][i]);
                String element = toVar(coeff, x[i], precision);
                
                elements[j][i] = element;
            }
        }
        
        return elements;
    }
    
    
    
    /*
     * Format a coefficient multiplied with
     * a variable as nicely as possible.
     */
    private String toVar(double coeff, String var, int precision) {
        if (coeff == 0.0) {
            return "";
        } else if (coeff == 1.0 && !var.trim().equals("")) {
            return var;
        }
        
        String f;
        if (precision < 0) {
            f = "%s%s"; // Automatically set precision.
        } else {
            f = String.format("%%.%df%%s", precision);
        }
        
        return String.format(f, coeff, var);
    }
}
